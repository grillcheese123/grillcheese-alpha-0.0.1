#version 450

/*
 * Hilbert Complex Similarity Compute Shader
 * 
 * GPU-accelerated complex inner product for Hilbert space routing.
 * Achieves 0.875 semantic correlation for memory retrieval.
 * 
 * Integration: vulkan_backend/shaders/hilbert_similarity.comp
 * 
 * Author: Nick [Redacted]
 * Date: January 2026
 */

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

// Push constants for configuration
layout(push_constant) uniform PushConstants {
    uint num_queries;      // Number of query vectors
    uint num_keys;         // Number of key vectors  
    uint dim;              // Embedding dimension
    float temperature;     // Softmax temperature
} params;

// Complex number representation: [real, imag] pairs
// Input: query embeddings [num_queries, dim * 2]
layout(std430, set = 0, binding = 0) readonly buffer QueryBuffer {
    float queries[];
};

// Input: key embeddings [num_keys, dim * 2]
layout(std430, set = 0, binding = 1) readonly buffer KeyBuffer {
    float keys[];
};

// Output: similarity scores [num_queries, num_keys]
layout(std430, set = 0, binding = 2) writeonly buffer OutputBuffer {
    float similarities[];
};

// Shared memory for reduction
shared float shared_real[256];
shared float shared_imag[256];
shared float shared_norm_q[256];
shared float shared_norm_k[256];

void main() {
    uint global_id = gl_GlobalInvocationID.x;
    uint local_id = gl_LocalInvocationID.x;
    uint group_id = gl_WorkGroupID.x;
    
    // Decode query and key indices from group_id
    uint query_idx = group_id / params.num_keys;
    uint key_idx = group_id % params.num_keys;
    
    if (query_idx >= params.num_queries || key_idx >= params.num_keys) {
        return;
    }
    
    // Each thread handles multiple dimensions
    float sum_real = 0.0;
    float sum_imag = 0.0;
    float norm_q = 0.0;
    float norm_k = 0.0;
    
    uint dims_per_thread = (params.dim + 255) / 256;
    
    for (uint i = 0; i < dims_per_thread; i++) {
        uint d = local_id + i * 256;
        
        if (d < params.dim) {
            // Complex indices: real at 2*d, imag at 2*d+1
            uint q_base = query_idx * params.dim * 2;
            uint k_base = key_idx * params.dim * 2;
            
            float q_real = queries[q_base + d * 2];
            float q_imag = queries[q_base + d * 2 + 1];
            float k_real = keys[k_base + d * 2];
            float k_imag = keys[k_base + d * 2 + 1];
            
            // Complex conjugate inner product: <q, k> = sum(conj(q) * k)
            // conj(q) = (q_real, -q_imag)
            // conj(q) * k = (q_real * k_real + q_imag * k_imag, q_real * k_imag - q_imag * k_real)
            sum_real += q_real * k_real + q_imag * k_imag;
            sum_imag += q_real * k_imag - q_imag * k_real;
            
            // Norms
            norm_q += q_real * q_real + q_imag * q_imag;
            norm_k += k_real * k_real + k_imag * k_imag;
        }
    }
    
    // Store in shared memory for reduction
    shared_real[local_id] = sum_real;
    shared_imag[local_id] = sum_imag;
    shared_norm_q[local_id] = norm_q;
    shared_norm_k[local_id] = norm_k;
    
    barrier();
    
    // Parallel reduction
    for (uint stride = 128; stride > 0; stride >>= 1) {
        if (local_id < stride) {
            shared_real[local_id] += shared_real[local_id + stride];
            shared_imag[local_id] += shared_imag[local_id + stride];
            shared_norm_q[local_id] += shared_norm_q[local_id + stride];
            shared_norm_k[local_id] += shared_norm_k[local_id + stride];
        }
        barrier();
    }
    
    // Thread 0 computes final similarity
    if (local_id == 0) {
        float inner_mag = sqrt(shared_real[0] * shared_real[0] + shared_imag[0] * shared_imag[0]);
        float norm_product = sqrt(shared_norm_q[0]) * sqrt(shared_norm_k[0]);
        
        float sim = 0.0;
        if (norm_product > 1e-12) {
            sim = inner_mag / norm_product;
        }
        
        // Store result
        similarities[query_idx * params.num_keys + key_idx] = sim;
    }
}
